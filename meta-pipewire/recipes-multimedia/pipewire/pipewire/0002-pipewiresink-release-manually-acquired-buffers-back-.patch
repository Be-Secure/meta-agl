From 8911e22793ed3713ceb78be5414eeb03ebde962e Mon Sep 17 00:00:00 2001
From: George Kiagiadakis <george.kiagiadakis@collabora.com>
Date: Mon, 10 May 2021 17:25:57 +0300
Subject: pipewiresink: release manually acquired buffers back to the pool

When we manually acquire buffers from the pool, we never release them.
But because gst_buffer_pool_acquire_buffer() adds a reference to the pool,
this leaks the pool eventually.

To fix this, just unref the buffer after it has been sent. This releases
it back to the pool and unrefs the pool.

This has no significant effect to the stream, since the underlying
pw buffers are actually pooled in the pw_stream. It just prevents leaking.

Upstream-Status: Backport [from master/0.3.28]
---
 src/gst/gstpipewiresink.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/gst/gstpipewiresink.c b/src/gst/gstpipewiresink.c
index 031b3ae0..2f79a4f7 100644
--- a/src/gst/gstpipewiresink.c
+++ b/src/gst/gstpipewiresink.c
@@ -578,6 +578,7 @@ gst_pipewire_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
   GstPipeWireSink *pwsink;
   GstFlowReturn res = GST_FLOW_OK;
   const char *error = NULL;
+  gboolean unref_buffer = FALSE;
 
   pwsink = GST_PIPEWIRE_SINK (bsink);
 
@@ -620,6 +621,7 @@ gst_pipewire_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
     gst_buffer_unmap (b, &info);
     gst_buffer_resize (b, 0, gst_buffer_get_size (buffer));
     buffer = b;
+    unref_buffer = TRUE;
 
     pw_thread_loop_lock (pwsink->core->loop);
     if (pw_stream_get_state (pwsink->stream, &error) != PW_STREAM_STATE_STREAMING)
@@ -628,6 +630,8 @@ gst_pipewire_sink_render (GstBaseSink * bsink, GstBuffer * buffer)
 
   GST_DEBUG ("push buffer");
   do_send_buffer (pwsink, buffer);
+  if (unref_buffer)
+    gst_buffer_unref (buffer);
 
 done_unlock:
   pw_thread_loop_unlock (pwsink->core->loop);
-- 
2.30.2

